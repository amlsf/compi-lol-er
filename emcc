#!/usr/bin/env python


import sys
import ply.lex as lex
from peak.util.assembler import Code
from dis import dis
from timeit import Timer
import marshal, struct, time, types

# vars for tokenizing
output = []
remain_tokens = []
constants_list = []
# list_tuples_form = []

# vars for parsing
symbol_table={}
symbol_list = []
parse_tree = []
token = None
# am I going to make scope an object?
scope = None

# vars for compiling
current_fun_return = None
# function names mapped to their code objects
fun_defs = {}


################################################################################
################################################################################
#######################       LEXING  TIME       ###############################
################################################################################
################################################################################

# declaring token names for ply lexer to use, including reserved keywords
tokens = [
    'EMCSQ', 'SLCOMMENT', 'SEMICOLON', 'GLOBAL', 'STRING', 'LPAREN', 'RPAREN', 'LBRACK', 'RBRACK', 'LCBRACE', 'RCBRACE', 'DOT', 'COMMA', 'COLON', 'ARROWED', 'ASSIGN', 'PLUS', 'MINUS', 'TIMES', 'DIVIDE', 'POWER', 'MODULO', 'LESS', 'GREATER', 'LESSEQ', 'GREATEQ', 'ISEQ', 'NOTEQ', 'ID','NUMBER',
    'USE', 'FUN', 'RETURN', 'CALL', 'ITEMIN', 'LOG', 'IF', 'ELIF', 'ELSE', 'OR', 'ORIF', 'AND', 'NOT', 'TYNONE', 'TYINT', 'TYSTRING', 'TYLIST', 'TYBOOL', 'TYMAP', 'TRUE', 'FALSE', 'EMPTY', 'BOUNDS', 'VAR', 'PIPE', 'USERINPUT', 'BANG', 'SEND', 'LIST', 'MAP', 'WHILE', 'DO', 'CONTINUE', 'BREAK'
    ] #+ list(reserved.values())


# Ignored characters
t_ignore = ' \t\v\r' # ignres ALL whitespace (but not newlines, so those can be counted--just tabs, vertical tabs, and carriage returns)

states = (
    ('emcomment','exclusive'),
)

t_emcomment_ignore = ' \t\v\r'

# def t_SLCOMMENT(t):
#     r'//[^:][^\n]*'
#     pass

def t_begin_emcomment(token):
    r'//:'
    token.lexer.begin('emcomment')

def t_emcomment_end(token):
    r'://'
    # makes sure to count lines
    token.lexer.lineno += token.value.count('\n')
    # goes back to non-comment mode
    token.lexer.begin('INITIAL')

def t_emcomment_error(token):
    # skips over EVERYTHING you find until you get to the end of the comment
    # this is similar to pass, but gathers up all the symbols so that you can count the newlines later at the t_emcomment_end part
    token.lexer.skip(1)

def t_newline(t):
    r'\n+'
    t.lexer.lineno += len(t.value)
        # += t.value.count("\n")

    
def t_error(t):
    print("Illegal character '%s'" % t.value[0])
    t.lexer.skip(1)


# TODO: EASTER EGG SHENANIGANS...do I want to allow anything to be written within the brackets? If so, what do I want to happen with that?

# def t_EMCSQ(t):
#     r'EmC\[\]'
#     return t


##### CLASS FOR BASIC TOKEN #####

class TokTemplate(object):
    # usually the left side in expressions
    first = None
    # usually the right side in expressions
    second = None
    # primarily for if, elses, etc
    third = None

    def __init__(self, type, value, pos):
        self.type = type
        self.value = value
        self.pos = pos
    def nulld(self):
        raise SyntaxError(
            "Syntax error when calling nulld for (%r)." % self.value
        )

    def leftd(self, left):
        raise SyntaxError(
            "Syntax error when calling leftd for (%r)." % self.value
        )

    def __repr__(self):
        return "(Type: %s; Value: '%s'; Position: %s)" % (self.type, self.value, self.pos)


##### CLASSES FOR BASIC STATEMENT TOKENS #####

class TokStatement(TokTemplate):
    def __init__(self, type, value, pos):
        self.type = type
        self.value = value
        self.pos = pos

class TokType(TokStatement):
    def __init__(self, type, value, pos):
        self.type = type
        self.value = value
        self.pos = pos    


##### CLASSES FOR END-Y TOKENS #####
class TokLast(TokTemplate):
    lbp = 0
    def leftd(self):
        pass
    def nulld(self):
        pass

class TokNewLine(TokTemplate):
    lbp = 0
    def leftd(self):
        pass
    def nulld(self):
        pass

class TokSemicolon(TokTemplate):
    lbp = 0
    def leftd(self):
        pass
    def nulld(self):
        pass

class TokRParen(TokTemplate):
    lbp = 0
    def leftd(self):
        pass
    def nulld(self):
        pass

class TokRBrack(TokTemplate):
    lbp = 0
    def leftd(self):
        pass
    def nulld(self):
        pass

class TokRCBrace(TokTemplate):
    lbp = 0
    def leftd(self):
        pass
    def nulld(self):
        pass

##### CLASSES FOR CONSTANT TOKENS #####
class TokId(TokTemplate):
    # '''does it need lbp?'''
    lbp = 0
    def nulld(self):
        symbol_list.append(self.value)
        return self
    
    def eval(self):
        return symbol_table[self.value]
    
    def emit(self, c):
        # - When being assigned (in tok var or tok assign), this will be a store_fast
            # --> therefore, this should be load_const and 
        # - All other times, this should be a load_const because whatever the id is pointing to should be used in an expression instead
        # TODO: this needs to grab a temporary iterator's ID/value if it's in a loop...so...how does one do that ONLY in that instance?
        print "load const of whatever's mapped to", self.value, ":", symbol_table[self.value]
        c.LOAD_FAST(self.value)

class TokString(TokTemplate):
    def nulld(self):
        return self
    def eval(self):
        return self.value
    def emit(self, c):
        c.LOAD_CONST(self.value)

class TokNumb(TokTemplate):
    lbp = 10
    def nulld(self):
        return self
    def eval(self):
        return self.value
    def emit(self, c):
        print "load const:", self.value
        c.LOAD_CONST(self.value)

class TokTrue(TokTemplate):
    def nulld(self):
        return self 
    def eval(self):
        return True
    def emit(self, c):
        c.LOAD_CONST(True)

class TokFalse(TokTemplate):
    def nulld(self):
        return self 
    def eval(self):
        return False
    def emit(self, c):
        c.LOAD_CONST(False)

class TokEmpty(TokTemplate):
    def nulld(self):
        return self 
    def eval(self):
        return None
    def emit(self, c):
        c.LOAD_CONST(None)


##### CLASSES FOR EXPRESSION TOKENS #####

# infix_r("or", 30)
class TokOr(TokTemplate):
    lbp = 30
    def leftd(self, left):
        self.first = left
        self.second = expression(30)
        return self 
    def eval(self):
        if self.first.eval() is True:
            print "%s is true so returning True" % self.first
            return True
        elif self.second.eval() is True:
            print "%s is true so returning True" % self.second
            return True
        else:
            print "Neither %s nor %s are true so returning False" % (self.first, self.second)
            return False


class TokOrif(TokTemplate):
    lbp = 30


# infix_r("and", 40)
class TokAnd(TokTemplate):
    lbp = 40
    def leftd(self, left):
        self.first = left
        self.second = expression(30)
        return self 
    def eval(self):
        if self.first.eval() is True and self.second.eval() is True:
            print "%s and %s are true so returning True" % (self.first, self.second)
            return True
        else:
            print "Either %s or %s is false so returning False" % (self.first, self.second)
            return False
    def emit(self, c):
        pass
        # self.first.emit(c)
        # c.POP_JUMP_IF_FALSE() #jump
        # load first
        # jump if false


# followed by "in", "not in"
# infix_r("not", 50)
class TokNot(TokTemplate):
    lbp = 50
    def leftd(self, left):
        self.first = left
        self.second = expression(50)
        return self 
    def eval(self):
        if self.first.eval() != self.second.eval():
            return True
        else:
            return False
    def emit(self, c):
        pass

# infix("in", 60)
class TokInNotIn(TokTemplate):
    lbp = 60
    def leftd(self, left):
        if token.value != "in":
            raise SyntaxError("Invalid syntax")
        advance()
        self.value = "not in"
        self.first = left
        self.second = expression(60)
        return self
        lbp = 60
    def emit(self, c):
        pass

# infix("not", 60) # in, not in
class TokNotNotIn(TokTemplate):
    lbp = 60    
    def leftd(self, left):
        if token.id != "not":
            raise SyntaxError("Invalid syntax")
        advance()
        self.id = "not in"
        self.first = left
        self.second = expression(60)
        return self
        lbp = 60

# infix("<", 60);
class TokLessThan(TokTemplate):
    lbp = 60
    def leftd(self, left):
        self.first = left
        self.second = expression(60)
        return self
    def eval(self):
        if self.first.eval() < self.second.eval():
            return True
        else:
            return False

# infix("<=", 60)
class TokLessOrEq(TokTemplate):
    lbp = 60
    def leftd(self, left):
        self.first = left
        self.second = expression(60)
        return self 
    def eval(self):
        if self.first.eval() <= self.second.eval():
            return True
        else:
            return False

# infix(">", 60) 
class TokGreaterThan(TokTemplate):
    lbp = 60
    def leftd(self, left):
        self.first = left
        self.second = expression(60)
        return self 
    def eval(self):
        if self.first.eval() >= self.second.eval():
            return True
        else:
            return False

# infix(">=", 60)
class TokGreaterOrEq(TokTemplate):
    lbp = 60
    def leftd(self, left):
        self.first = left
        self.second = expression(60)
        return self 
    def eval(self):
        if self.first.eval() >= self.second.eval():
            return True
        else:
            return False

# infix("!=", 60); 
class TokNotEq(TokTemplate):
    lbp = 60
    def leftd(self, left):
        self.first = left
        self.second = expression(60)
        return self 
    def eval(self):
        if self.first.eval() != self.second.eval():
            return True
        else:
            return False

# infix("==", 60)
class TokIsEqual(TokTemplate):
    lbp = 60
    def leftd(self, left):
        self.first = left
        self.second = expression(60)
        return self 
    def eval(self):
        if self.first.eval() == self.second.eval():
            return True
        else:
            return False    

# infix("+", 110) 
class TokPlus(TokTemplate):
    lbp = 110
    def leftd(self, left):
        self.first = left
        self.second = expression(110)
        return self
    def eval(self):
        print "added %r and %r" % (self.first, self.second)
        return self.first.eval() + self.second.eval()
    def emit(self, c):
        self.first.emit(c)
        self.second.emit(c)
        c.BINARY_ADD()
        print "binary adding going down"

# infix("-", 110)
class TokMinus(TokTemplate):
    lbp = 110
    def nulld(self):
        return -expression(110)
    def leftd(self, left):
        self.first = left
        self.second = expression(110)
        return self
    def eval(self):
        print "subtracted %r from %r" % (self.second, self.first)
        return self.first.eval() - self.second.eval()
    def emit(self, c):
        self.first.emit(c)
        self.second.emit(c)
        c.BINARY_SUBTRACT()

# infix("*", 120) 
class TokTimes(TokTemplate):
    lbp = 120
    def leftd(self, left):
        self.first = left
        self.second = expression(120)
        return self
    def eval(self):
        print "multiplied %r and %r" % (self.first, self.second)
        return self.first.eval() * self.second.eval()
    def emit(self, c):
        self.first.emit(c)
        self.second.emit(c)
        c.BINARY_MULTIPLY()


# infix("/", 120)
class TokDiv(TokTemplate):
    lbp = 120
    def leftd(self, left):
        self.first = left
        self.second = expression(120)
        return self 
    
    def eval(self):
        print "divided %d by %d" % (self.first.eval(), self.second.eval())
        return self.first.eval() / self.second.eval()
    
    def emit(self, c):
        self.first.emit(c)
        self.second.emit(c)
        c.BINARY_DIVIDE()

# infix("%", 120)
class TokModulo(TokTemplate):
    lbp = 120
    def leftd(self, left):
        self.first = left
        self.second = expression(120)
        return self     
    def eval(self):
        print "got remainder of %d modulo %d" % (self.first.eval(), self.second.eval())
        return self.first.eval() % self.second.eval()
    def emit(self, c):
        self.first.emit(c)
        self.second.emit(c)
        c.BINARY_MODULO()


# infix_r("^", 140)
class TokPower(TokTemplate):
    lbp = 140
    def leftd(self, left):
        self.first = left
        self.second = expression(140)
        return self 
    def eval(self):
        print "raised %d to pow of %d" ** (self.first.eval(), self.second.eval())
        return self.first.eval() ** self.second.eval()
    def emit(self, c):
        self.first.emit(c)
        self.second.emit(c)
        c.BINARY_POWER()


##### CLASSES FOR HIGH-BINDING POWER TOKENS #####

# symbol("[", 150)
class TokLBrack(TokTemplate):
    lbp = 150
    def leftd(self, left):
        self.first = left
        self.second = expression()
        advance("]")
        return self
    def nulld(self):
        self.first = []
        if token.id != "]":
            while 1:
                if token.id == "]":
                    break
                self.first.append(expression())
                if token.id != ",":
                    break
                advance(",")
        advance("]")
        return self

# symbol("(", 150)
class TokLParen(TokTemplate):
    lbp = 150
    def nulld(self):
        expr = expression()
        # expect to see a right paren, if you don't, break
        advance(TokRParen)
        return expr
        # TODO: HOW DO DISTINGUISH BETWEEN nullds, do I need both?
    # def nulld(self):
    #     self.first = []
    #     comma = False
    #     if token.value != ")":
    #         while 1:
    #             if token.value == ")":
    #                 break
    #             self.first.append(expression())
    #             if token.value != ",":
    #                 break
    #             comma = True
    #             advance(",")
    #     advance(")")
    #     if not self.first or comma:
    #         return self # tuple
    #     else:
    #         return self.first[0]
    def leftd(self, left):
        self.first = left
        self.second = []
        if token.value != ")":
            while True:
                self.second.append(expression())
                if token.value != ",":
                    break
                advance(",")
        advance(")")
        return self

# symbol("=", 160)
class TokAssign(TokTemplate):
    lbp = 160
    def leftd (self, left):
        self.first = left
        self.second = expression(160)
        return self
    
    def eval(self):
        symbol_table[self.first] = self.second.eval()
        print "Set", self.first, "to", self.second.eval()
    
    def emit(self, c):
        self.second.emit(c)
        c.STORE_FAST(self.first)

# symbol("{", 170)
class TokLCBrace(TokTemplate):
    lbp = 0
    def nulld(self):
        self.first = []
        if token.type != "}":
            while 1:
                if token.type == "}":
                    break
                self.first.append(expression())
                advance(":")
                self.first.append(expression())
                if token.type != ",":
                    break
                advance(",")
        advance("}")
        return self



##### CLASSES FOR STATEMENT TOKENS #####

# symbol("->", 140)
class TokArrowed(TokStatement):
    lbp = 140

# symbol(".", 150)
class TokDot(TokStatement):
    lbp = 150
    def leftd(self, left):
        if token.type != "ID":
            SyntaxError("Expected an attribute identifier for dot notation.")
        self.first = left
        self.second = token
        advance()
        return self

# symbol(",", 150)
class TokComma(TokStatement):
    lbp = 150


class TokColon(TokStatement):
    lbp = 0
    def stmtd(self):
        return self
    def eval(self):
        pass        

class TokBang(TokStatement):
    lbp = 0
    def stmtd(self):
        return self
    def eval(self):
        pass        


class TokGlobal(TokStatement):
    def stmtd(self):
        return self
    def eval(self):
        pass        

class TokPipe(TokStatement):
    def stmtd(self):
        return self
    def eval(self):
        pass

##### CLASSES FOR STATEMENT TOKENS -- RESERVED #####

class TokUse(TokStatement):
    def stmtd(self):
        advance(TokUse)
        self.first = (token.value)
        self.second = []
        advance(TokId)
        while not isinstance(token, TokSemicolon):
            advance(TokDot)
            self.first.append(token.value)
            advance(TokId)
        advance(TokSemicolon)
        return self

    def eval(self):
        methods = ''
        # if len(self.second) > 1:
            # from self.first import self.second[0].self.second[1]
        # if len(self.second) < 2:
        #     from self.first import self.second[0]
        # else:
        import self.first

    def emit(self, c):
        c.LOAD_CONST(-1)
        print "LOAD_CONST(-1)"
        c.LOAD_CONST(self.second)
        print "LOAD_CONST(what you're importing)"
        c.IMPORT_NAME(self.first)
        print "IMPORT_NAME(from which library)"
        if len(self.second) > 1:
            c.IMPORT_FROM(self.second)
            c.STORE_FAST(self.second)
        c.STORE_FAST(self.first)
        print "STORE_FAST(library name)"
        c.POP_TOP
        print "POP_TOP"


class TokFunction(TokStatement):
    def stmtd(self):
        advance(TokFunction)
        advance(TokLParen)
        # TODO: make function that loops to get all the arguments out for every token that requires it
        count = 0
        if not isinstance(token, TokRParen):
            self.args = {}
        while isinstance(token, TokType):
            advance(TokType)
            self.args["arg"+str(count)] = token.value
            print "adding", "arg"+str(count), token.value, "to args dict"
            count += 1
            advance(TokId)
            if isinstance(token, TokComma):
                advance(TokComma)
        advance(TokRParen)
        advance(TokArrowed)
        self.fun_name = token.value
        print "added function name to list values: ", self.fun_name
        advance(TokId)
        advance(TokArrowed)
        advance(TokType)
        advance(TokLCBrace)
        self.block = block()
        advance(TokRCBrace)
        return self
    
    def eval(self):
        pass 
    
    def emit(self, c):
        '''
        code objects fun: 
        funObj.co_filename represents 
        funObj.co_name will say module even though it could be function or class
        '''
        new_block = Code()
        print "Made a code object for this function:", new_block.co_filename
        new_block.co_argcount = len(self.args)
        self.block.emit(new_block)
        
        print "((nothing was returned in code obj, so add silent return to it))"
        if current_fun_return == False:
            new_block.LOAD_CONST(None)
            print "LOAD_CONST(None)"
            new_block.RETURN_VALUE()
            print "RETURN_VALUE"
        print self.args
        c.LOAD_CONST(new_block.code())
        print "LOAD_CONST(code obj)"
        c.MAKE_FUNCTION(0)
        print "MAKE_FUNCTION"
        fun_defs[self.fun_name] = new_block
        print "((mapping function name to code obj))"
        c.STORE_FAST(self.fun_name)
        print "STORE_FAST(function obj)"
        # dis(new_block.code())
        
class TokReturn(TokStatement):
    def stmtd(self):
        advance(TokReturn)
        if not isinstance(token, TokSemicolon):
            self.first = expression(0)
        else:
            self.first = None
    def eval(self):
        if self.first == None:
            return None
        else:
            return self.first.eval()
    def emit(self, c):
        global current_fun_return
        self.first.emit(c)
        c.RETURN_VALUE()
        print "RETURN_VALUE"
        if current_fun_return:
            current_fun_return = True

# EMC[]'s for loop
class TokCall(TokStatement):
    def stmtd(self):
        advance(TokCall)
        self.tempvar = token.value
        # keep id in memory though it'll be changed in every iteration
        advance(TokId)
        advance(TokItemIn)
        # Different types of forms: #listA #someString #bounds(10)=list0-9 
        # #bounds(3:6)=list3-6 #bounds(3:6!2)=list[3,5] #bounds(10!-1)=list0-9backwards            
        iter_list = []
        if isinstance(token, TokId):
            # save that identifier to iterate through later, evaluation of which is different based on type of variable
            self.iter_scope = token.value
            print "set iterscope to ", token.value
        else: 
            # create an identifier to iterate through later, based on bounds
            advance(TokBounds)
            advance(TokLParen)
            # TODO: must set up system to fill anything within a function that uses/could use an argument with some PLACEHOLDER until the function is actually called--should placeholder just be variable's name?
            first_num = expression(0)
            # if there's a colon following, then the first number was the self.fromNum, otherwise that number represents the range that the user wants to loop until, non-inclusively (so if bounds(10), it would iterate through a list of 10 items, 0 through 9)
            if isinstance(token, TokColon):
                self.from_num = first_num
                advance(TokColon)
                self.to_num = expression(0)
            else:
                self.range = first_num
            # if there's a '!' token then the list will be manipulated in terms of direction and/or frequency before being iterated through
            if isinstance(token, TokBang):
                advance(TokBang)
                potential_freq = expression(0)
                # 1 is default direc/freq, so ignore it
                if potential_freq != 1:
                    self.frequency = potential_freq
            advance(TokRParen)
            advance(TokLCBrace)
            self.block = block()
            advance(TokRCBrace)

        return self

    def eval(self):
        pass
        # # DOING THIS WITHOUT PYTHON LIST MANIPULATION for better visualization of translating it into bytecode based on what's really happening
        # # self.tempvar is what will be increasing after every iteration
        # # self.range is if just 1 number exists, create complete list
        # # global 
        # iter_list = []
        # if hasattr(self, 'range'):
        #     x = 0
        #     # TODO: write function to distinguish between if value is 
        #     self.range = get_value(self.range)
        #     print self.range, "raaaaaaaaaaange"
        #     while x < self.range(c):
        #         iter_list.append(x)
        #         x += 1
        #         print x
        # if hasattr(self, 'from_num'):
        #     x = self.from_num
        #     if isinstance(x, TokId):
        #         x = symbol_table[x]
        #     elif isinstance(x, TokNumb):
        #         x = x.value
        #     print "WHAT ISSSSSSSSSSSSSSS x", x
        #     print "runs untillllllll", self.to_num
        #     while x < self.to_num.emit(c):
        #         iter_list.append(x)
        #         x += 1
        #         print iter_list, "LIIIIIIIST"
        # if hasattr(self, 'frequency'):
        #     if self.frequency.emit(c) < 0:
        #         # reverse list
        #         pass
        #     if self.frequency.emit(c) > 1 or self.frequence <-1:
        #         # take out every _ one
        #         pass
        # self.list = iter_list
        # # print "LIST FOR ITERATIONNNNNNNNNNNNNNNN", iterList
        # self.list = iterList
        # for x in iterList:
        #     # changes value in the symbol table so that wherever it's used, it will have the correct value
        #     symbol_table[self.tempvar] = x
        #     self.block.eval()
        # # after the loop is done, variable is removed from symbol_table so the name can be used again
        # del symbol_table[self.tempvar]


    def emit(self, c):
        c.SETUP_LOOP()
        # TODO: manipulate lists before sending into be put into the loop, this will be an if, else, because the process of loading the results into code gen will be different for manipulated ones (load each item as const, then build list, then get iter)
        if hasattr(self, 'frequency'):
            if self.frequency.value < 0:
                # reverse list
                print "freq. manip. to be added later"
            if self.frequency.value > 1 or self.frequency.value <-1:
                # take out every _ one
                print "freq. manip. to be added later"
            # self.list = iter_list
            # for x in self.list:
            #     # changes value in the symbol table so that wherever it's used, it will have the correct value
            #     symbol_table[self.tempvar] = x
            #     self.block.emit(c)
            # after the loop is done, variable is removed from symbol_table so the name can be used again
            # del symbol_table[self.tempvar]

            # for list_item in self.list: # used IF not "bounds" but the ID of some list
            #     c.LOAD_CONST(list_item)
                # c.BUILD_LIST(len(self.list))
                # c.STORE_FAST()
                # c.LOAD_FAST()
        # if not manipulating list first, it's much easier
        if hasattr(self, 'range'):
            print self.range, "raaaaaaaaaaange"
            c.LOAD_GLOBAL('xrange')
            print "LOAD_GLOBAL(xrange)"
            c.LOAD_CONST(self.range.value)
            print "LOAD_CONST(%s)" % self.range.value
            c.CALL_FUNCTION(1, 0)
            print "CALL_FUNCTION(1 arg[range], 0 key args)"

        elif hasattr(self, 'from_num'):
            c.LOAD_GLOBAL('xrange')
            print "LOAD_GLOBAL(xrange)"
            c.LOAD_CONST(self.from_num.value)
            print "LOAD_CONST(%s)" % self.from_num.value
            c.LOAD_CONST(self.to_num.value)
            print "LOAD_CONST(%s)" % self.to_num.value
            c.CALL_FUNCTION(2, 0)
            print "CALL_FUNCTION(2 args[start, stop-exclusive], 0 key args)"
        c.GET_ITER()
        print "GET_ITER(the list created/loaded)"
        loop_start = c.here()
        print "LOOP START =", loop_start
        loop_end = c.FOR_ITER()
        print "FOR_ITER(sets line to jump back to after every runthrough of the body)"
        # TODO: how does one get the correct variable name? do you pass it in with 'c' when emitting?
        c.STORE_FAST(self.tempvar)
        print "STORE_FAST(temp var name:", self.tempvar,")"
        # c.LOAD_FAST(self.tempvar)
        # print "LOAD_FAST", self.tempvar
        self.block.emit(c)
        c.JUMP_ABSOLUTE(loop_start) # JUMPS TO FOR_ITER
        print "JUMP_ABSOLUTE", loop_start
        loop_end()
        c.POP_BLOCK() # MARKS END OF LOOP BODY
        print "POP_BLOCK"

class TokWhile(TokStatement):
    def stmtd(self):
        advance(TokWhile)
        if isinstance(token, TokLParen):
            advance(TokLParen)
            self.while_cond = expression(0)
            advance(TOkRParen)
        else:
            self.while_cond = expression(0)
        advance(TokDo)
        advance(TokLCBrace)
        self.block = block()
        advance(TokRCBrace)
        return self
    
    def eval(self):
        pass
    
    def emit(self, c):
        c.SETUP_LOOP()
        self.while_cond.emit(c)
        fwd = c.JUMP_IF_FALSE()

        c.GET_ITER()
        print "GET_ITER(the list created/loaded)"
        loop_start = c.here()
        print "LOOP START =", loop_start
        loop_end = c.FOR_ITER()
        print "FOR_ITER(sets line to jump back to after every runthrough of the body)"
        # TODO: how does one get the correct variable name? do you pass it in with 'c' when emitting?
        c.STORE_FAST(self.tempvar)
        print "STORE_FAST(temp var name:", self.tempvar,")"
        # c.LOAD_FAST(self.tempvar)
        # print "LOAD_FAST", self.tempvar
        self.block.emit(c)
        c.JUMP_ABSOLUTE(loop_start) # JUMPS TO FOR_ITER
        print "JUMP_ABSOLUTE", loop_start
        loop_end()

        fwd()
        c.POP_BLOCK()
        print "POP_BLOCK"


class TokItemIn(TokStatement):
    def stmtd(self):
        return self
    def eval(self):
        pass
    def emit(self, c):
        pass

class TokLog(TokStatement):
    def stmtd(self):
        advance(TokLog) # skip past 'log'
        advance(TokLParen) # skip past l paren
        self.first = expression(0)
        advance(TokRParen)
        advance(TokSemicolon)
        return self

    def eval(self):
        print self.first.eval()

    def emit(self, c):
        print "OHAAAAAAAAAY", self.first
        self.first.emit(c)
        c.PRINT_ITEM()
        print "PRINT_ITEM"
        c.PRINT_NEWLINE()
        print "PRINT_NEWLINE"

# symbol("if", 20) 
# ternary form
class TokIf(TokStatement):
    def stmtd(self):
        advance(TokIf)
        self.ifcond = expression(0)
        advance(TokLCBrace)
        self.ifresult = statement()
        advance(TokRCBrace)
        if token.type == "ELIF":
            advance(TokElif)
            self.elifcond = expression(0)
            advance(TokLCBrace)
            while not isinstance(token, TokRCBrace): 
                self.elifresult = statement()
            advance(TokRCBrace)
        # TODO: cannot yet do infinite elifs with this grammar
        if token.type == "ELSE":
            advance(TokElse)
            self.elsecond = expression(0)
            advance(TokLCBrace)
            while not isinstance(token, TokRCBrace): 
                self.elseresult = statement()
            advance(TokRCBrace)    
        # evaluate the conditional
        # if conditional true, 
        # if next token is 'elif', 
        return self

    def eval(self):
        if self.ifcond.eval() is True:
            print self.ifcond.eval(), "is true, so..."
            self.ifresult.eval()
        else:
            print self.ifcond.eval(), "is not true, so skip THIS."
            # checks to see if there is a self.elifcond
            if hasattr(self, 'elifcond'):
                if self.elifcond.eval() is True:
                    print self.elifcond.eval(), "is true, so..."
                    self.elifresult.eval()
                else:
                    print self.elifcond.eval(), "is not true, so skip THIS."
                    # checks to see if there is a self.elsecond
                    if hasattr(self, 'elsecond'):
                        if self.elsecond.eval() is True:
                            print self.elsecond.eval(), "is true, so..."
                            self.elseresult.eval()
                            '''could this be cleaned up? due to repeating code?'''
            else:
                if hasattr(self, 'elsecond'):
                    if self.elsecond.eval() is True:
                        print self.elsecond.eval(), "is true, so..."
                        self.elseresult.eval()
    def emit(self, c):
        '''Disassembled if false print 'yay', if true print 'noooo':
        0 LOAD_GLOBAL 0(false)
        3 POP_JUMP_IF_False 14
        6 LOAD_CONST 1("Yay!")
        9 PRINT_ITEM ()
        10 PRINT_NEWLINE
        11 JUMP_FORWARD 14 (to 28)
        14 LOAD_GLOBAL 1(true)
        17 POP_JUMP_IF_FALSE 28
        20 LOAD_CONST 2 ('nooooo')
        23 PRINT_ITEM
        24 PRINT_NEWLINE
        25 JUMP_FORWARD 0 (to 28)
        28 LOAD_CONST 0 (None)
        31 RETURN_VALUE
        '''
        # c.LOAD_GLOBAL(self.ifcond.eval())

# symbol("if", 20) 
# ternary form
class TokElif(TokStatement):
    def stmtd(self):
        return self
    def eval(self):
        pass

# symbol("if", 20) 
# ternary form
class TokElse(TokStatement):
    def stmtd(self):
        return self
    def eval(self):
        pass

class TokBounds(TokStatement):
    def stmtd(self):
        return self
    def eval(self):
        pass

# EMC[]'s function call
class TokSend(TokStatement):
    def stmtd(self):
        advance(TokSend)
        advance(TokLParen)
        self.args = []
        self.args.append(token)
        advance()
        while not isinstance(token, TokRParen):
            advance(TokComma)
            self.args.append(token)
            advance()
        advance(TokRParen)
        advance(TokArrowed)
        self.fun_name = token.value
        advance(TokId)
        # grammar has optional assignment of results
        if isinstance(token,TokArrowed):
            advance(TokArrowed)
            self.result_dump = token.value
            advance()
        advance(TokSemicolon)
        return self

    def eval(self):
        pass
    
    def emit(self, c):
        c.LOAD_FAST(self.fun_name)
        print self.args
        for arg in self.args:
            arg.emit(c)
        # CALL_FUNCTION takes 2 args: 1=positional args, 2=keyword args
        c.CALL_FUNCTION(len(self.args), 0)
        # if it's being assigned to something, it'll automatically pop the function results off the stack by way of "STORE_FAST"
        if hasattr(self, 'result_dump'):
            c.STORE_FAST(self.result_dump)
        # if it just runs things, the results or None will need to be popped off
        else:
            c.POP_TOP()
        # get function object from dictionary

class TokVar(TokStatement):
    def stmtd(self):
        advance(TokVar)
        advance(TokType)
        advance(TokPipe)
        # TODO: add ID to official symbol table/list now or when you walk through the tree?
        self.newvar = token.value
        # send the rest into expression
        advance(TokId)
        advance(TokAssign)
        # if assignment is creating a list
        self.setvalue = type_data()
        print "WHAT ARE WE SETTING THINGS TOOOOOOOO:", self.setvalue
        advance(TokSemicolon)
        return self

    def eval(self):
        global symbol_list
        # add ID to symbol list so you can use it during assignment
        symbol_list.append(self.newvar)
        print "added '%s' to the symbol_list" % self.newvar
        symbol_table[self.newvar] = self.setvalue.eval()
        print "added '%s' as key to the value of '%s'" % (self.newvar, self.setvalue.eval())
    
    def emit(self, c):
        symbol_table[self.newvar] = self.setvalue.eval()
        print "Setting", self.newvar, "to", self.setvalue, " eval:", self.setvalue.eval()
        if isinstance(self.setvalue, types.ListType):
            pass
        elif isinstance(self.setvalue, types.DictType):
            pass
        else:
            self.setvalue.emit(c)
        c.STORE_FAST(self.newvar)
        print "ASSIIIIIIIIGN: store fast", self.newvar


class TokUserInput(TokStatement):
    def stmtd(self):
        return self
    def eval(self):
        pass

##### CLASSES FOR TYPE TOKENS #####

class TokTypeNone(TokType):
    def stmtd(self):
        return self
    def eval(self):
        pass

class TokTypeInt(TokType):
    def stmtd(self):
        return
    def eval(self):
        pass

class TokTypeString(TokType):
    def stmtd(self):
        return self
    def eval(self):
        pass

class TokTypeList(TokType):
    def stmtd(self):
        return self
    def eval(self):
        pass

class TokTypeBool(TokType):
    def stmtd(self):
        return self
    def eval(self):
        pass

class TokTypeMap(TokType):
    def stmtd(self):
        return self
    def eval(self):
        pass


# METHODS FOR CAPTURING REGEX TOKENS, MAKING OBJECTS

# METHODS FOR EXPRESSION TOKENS

def t_PIPE(t):
    r'\|'
    t = TokPipe(t.type, t.value, t.lexpos)
    return t

def t_NUMBER(t):
    r'-?((\d+(\.\d+)?)|(\.\d+))' # should include neg/pos either '[nums]' or '[nums].[nums]' or '.[nums]''
    try:
        t.value = int(t.value)
    except ValueError:
        print("Integer value too large %d", t.fvalue)
        t.value = 0
    # return float(t)
    t = TokNumb(t.type, t.value, t.lexpos)
    return t

def t_STRING(t):
    r'''("[^"]*")|('[^"]*')'''  # |(\'[^']*\')' # must have line count
    sansquotes = t.value[1:-1]
    t = TokString(t.type, sansquotes, t.lexpos)
    return t



def t_TRUE(t):
    r'true'
    t = TokTrue(t.type, t.value, t.lexpos)
    return t

def t_FALSE(t):
    r'false'
    t = TokFalse(t.type, t.value, t.lexpos)
    return t
    
def t_EMPTY(t):
    r'empty'
    t = TokEmpty(t.type, t.value, t.lexpos)
    return t

def t_SEMICOLON(t):
    r';'
    t = TokSemicolon(t.type, t.value, t.lexpos)
    return t

def t_GLOBAL(t):
    r'\\/'
    t = TokGlobal(t.type, t.value, t.lexpos)
    return t

def t_LPAREN(t):
    r'\('
    t = TokLParen(t.type, t.value, t.lexpos)
    return t

def t_RPAREN(t):
    r'\)'
    t = TokRParen(t.type, t.value, t.lexpos)
    return t

def t_LBRACK(t):
    r'\['
    t = TokLBrack(t.type, t.value, t.lexpos)
    return t

def t_RBRACK(t):
    r'\]'
    t = TokRBrack(t.type, t.value, t.lexpos)
    return t

def t_LCBRACE(t):
    r'\{'
    t = TokLCBrace(t.type, t.value, t.lexpos)
    return t

def t_RCBRACE(t):
    r'\}'
    t = TokRCBrace(t.type, t.value, t.lexpos)
    return t

def t_DOT(t):
    r'\.'
    t = TokDot(t.type, t.value, t.lexpos)
    return t

def t_COMMA(t):
    r','
    t = TokComma(t.type, t.value, t.lexpos)
    return t

def t_COLON(t):
    r':'
    t = TokColon(t.type, t.value, t.lexpos)
    return t

def t_ARROWED(t):
    r'->'   # or '-->' ?
    t = TokArrowed(t.type, t.value, t.lexpos)
    return t

def t_ISEQ(t):
    r'=='
    t = TokIsEqual(t.type, t.value, t.lexpos)
    return t

def t_ASSIGN(t):
    r'='
    t = TokAssign(t.type, t.value, t.lexpos)
    return t

def t_PLUS(t):
    r'\+'
    t = TokPlus(t.type, t.value, t.lexpos)
    return t

def t_MINUS(t):
    r'-'
    t = TokMinus(t.type, t.value, t.lexpos)
    return t

def t_TIMES(t):
    r'\*'
    t = TokTimes(t.type, t.value, t.lexpos)
    return t

def t_DIVIDE(t):
    r'/'
    t = TokDiv(t.type, t.value, t.lexpos)
    return t

def t_POWER(t):
    r'\^'
    t = TokPower(t.type, t.value, t.lexpos)
    return t

def t_MODULO(t):
    r'%'
    t = TokModulo(t.type, t.value, t.lexpos)
    return t

def t_LESS(t):
    r'<'
    t = TokLessThan(t.type, t.value, t.lexpos)
    return t

def t_GREATER(t):
    r'>'
    t = TokGreaterThan(t.type, t.value, t.lexpos)
    return t

def t_LESSEQ(t):
    r'<='
    t = TokLessOrEq(t.type, t.value, t.lexpos)
    return t

def t_GREATEQ(t):
    r'>='
    t = TokGreaterOrEq(t.type, t.value, t.lexpos)
    return t

def t_NOTEQ(t):
    r'!='
    t = TokNotEq(t.type, t.value, t.lexpos)
    return t

def t_BANG(t):
    r'!'
    t = TokBang(t.type, t.value, t.lexpos)
    return t

##### METHODS FOR STATEMENT TOKENS #####

def t_USE(t):
    r'use'
    t = TokUse(t.type, t.value, t.lexpos)
    return t

def t_FUN(t):
    r'fun'
    t = TokFunction(t.type, t.value, t.lexpos)
    return t

def t_RETURN(t):
    r'return'
    t = TokReturn(t.type, t.value, t.lexpos)
    return t

def t_CALL(t):
    r'call'
    t = TokCall(t.type, t.value, t.lexpos)
    return t

def t_ITEMIN(t):
    r'itemin'
    t = TokItemIn(t.type, t.value, t.lexpos)
    return t

def t_BOUNDS(t):
    r'bounds'
    t = TokBounds(t.type, t.value, t.lexpos)
    return t    

def t_SEND(t):
    r'send'
    t = TokSend(t.type, t.value, t.lexpos)
    return t

def t_LOG(t):
    r'log'
    t = TokLog(t.type, t.value, t.lexpos)
    return t

def t_IF(t):
    r'if'
    t = TokIf(t.type, t.value, t.lexpos)
    return t

def t_ELIF(t):
    r'elif'
    t = TokElif(t.type, t.value, t.lexpos)
    return t

def t_ELSE(t):
    r'else'
    t = TokElse(t.type, t.value, t.lexpos)
    return t

def t_TYINT(t):
    r'int'
    t = TokTypeInt(t.type, t.value, t.lexpos)
    return t

def t_TYSTRING(t):
    r'string'
    t = TokTypeString(t.type, t.value, t.lexpos)
    return t

def t_TYLIST(t):
    r'list'
    t = TokTypeList(t.type, t.value, t.lexpos)
    return t

def t_TYBOOL(t):
    r'bool'
    t = TokTypeBool(t.type, t.value, t.lexpos)
    return t

def t_TYMAP(t):
    r'map'
    t = TokTypeMap(t.type, t.value, t.lexpos)
    return t

def t_TYNONE(t):
    r'none'
    t = TokTypeNone(t.type, t.value, t.lexpos)

def t_VAR(t):
    r'var'
    t = TokVar(t.type, t.value, t.lexpos)
    return t

def t_WHILE(t):
    r'while'
    t = TokWhile(t.type, t.value, t.lexpos)
    return

def t_DO(t):
    r'do'
    t = TokDo(t.type, t.value, t.lexpos)
    return

# def t_CONTINUE(t):
#     r'continue'
#     t = TokContinue(t.type, t.value, t.lexpos)
#     return

# def t_BREAK(t):
#     r'break'
#     t = TokBreak(t.type, t.value, t.lexpos)
#     return

##### ID DEF MUST COME LAST SO RESERVED WORDS CAUGHT FIRST #####

def t_ID(t):
    r'[a-zA-Z_][a-zA-Z0-9_]*'
    # t.type = reserved.get(t.value,'ID')
    t = TokId(t.type, t.value, t.lexpos)
    return t

def get_value(mystery):
    print "SOOOOOLVING THE MYSTERIES OF WHAT KIND OF THING IS THIS"
    if isinstance(mystery, TokId):
        mystery_solved = symbol_table[mystery]
    elif isinstance(x, TokNumb):
        mystery_solved = mystery.value
    else:
        "WTF IS THIS AND WHY IS IT HEEEEEERE", x
    return mystery_solved

def argument_list(list):
    while True:
        if token.type != "ID":
            SyntaxError("Expected an argument identifier.")
        list.append(token)
        advance()
        if token.type == "=":
            advance()
            list.append(expression())
        else:
            list.append(None)
        if token.value != ",":
            break
        advance(",")


def type_data():
    if isinstance(token, TokLBrack):
        data = []
        advance(TokLBrack)
        data.append(token.value)
        advance()
        while not isinstance(token, TokRBrack):
            advance(TokComma)
            data.append(token.value)
            advance()
        advance(TokRBrack)
    elif isinstance(token, TokLCBrace):
        data = {}
        advance(TokLCBrace)
        tempkey = token.value
        advance() # advance past whatever the key is
        advance(TokArrowed)
        data[tempkey] = token.value
        # TODO: make dictionarys able to take things other than ID's, constants
        advance() # advance past whatever the value is
        while not isinstance(token, TokRCBrace):
            advance(TokComma)
            tempkey = token.value
            advance() # advance past whatever the key is
            advance(TokArrowed)
            data[tempkey] = token.value
            advance() # advance past whatever the value is
        advance(TokRCBrace)
    else: 
        data = expression(0)
    return data



################################################################################
################################################################################
#######################       PARSING TIME       ###############################
################################################################################
################################################################################


def em_lexer(file_name): # lexer,input_script):
    global remain_tokens
    global constants_list
    global symbol_list
    global symbol_list
    # Build the lexer
    emcsqlexer = lex.lex()
    # def tokenize():
    input_script = open(file_name).read()
    emcsqlexer.input(input_script)
    # Tokenizer
    while True:

        tok = emcsqlexer.token()
        
        if not tok: break
        
        # construct list of token objects to be parsed
        remain_tokens.append(tok)

        # construct constants
        if tok.type == 'STRING' or tok.type == 'NUMBER':
            constants_list += (tok.type, tok.value)

        # construct symbols
        if tok.type == 'ID':
            symbol_list.append(tok.value)
            if tok.value not in symbol_table:
                symbol_table[tok.value] = tok.type
        # print tok.type, tok.value, tok.lexpos


# Printing pretty tokenized creations
def display_lexing():
    # print "Raw EMC[] input: \n", input_script
    print "\n\nTokens: \n",remain_tokens
    print "\n\nIn symbol table:"
    for key, value in symbol_table.iteritems():
        print key
    print "\n\nList of constants: \n", constants_list, "\n\n"



##### METHODS FOR PARSING PROCESS #####

class Program(object):
    def stmtd(self):
        # all the baby statement lists
        self.chilluns = statement_list() 
        return self

    def eval(self):
        # iterates through the list of statement
        for child in self.chilluns:
            child.eval()

    def emit(self, c):
        for child in self.chilluns:
            child.emit(c)

class Block(object):
    def __init__(self, statements):
        self.chilluns = statements
    def stmtd(self):
        # all the baby statement lists
        self.chilluns = block() 
        return self

    def eval(self):
        # iterates through the list of statement
        for child in self.chilluns:
            child.eval()

    def emit(self, c):
        for child in self.chilluns:
            child.emit(c)


# debugging counter to see how many iterations have run
depth = 0
def parse():
    # set token to first of whole program
    advance()
    p = Program()
    # sets its chilluns 
    p.stmtd()
    return p


def statement_list():
    statements = []
    # make list, each item of which is either a statement or an expression
    while not isinstance(token, TokLast):
        statements.append(statement())
        if isinstance(token, TokSemicolon):
            advance(TokSemicolon)
    return statements

def block():
    stmts = []
    while not isinstance(token, TokRCBrace):
        stmts.append(statement())
    b = Block(stmts)
    return b

def statement():
    # if token is statement, run it's statement denotation
    if isinstance(token, TokStatement):
        return token.stmtd()
    # otherwise run the expression function
    return expression(0)


# nulld doesn't care about the tokens to left
    # nulld --> variables, literals, prefix op
# leftd cared about tokens to left
    # infix ops, suffix ops
# pratt calls this "def parse"
def expression(rbp=0):
    # t = current token (now considered previous token)
    t = token
    print "left is: ", t
    # make token the next one in the program
    advance()
    print "right is ", token
    # leftd = denotation of the previous token
    left = t.nulld()
    # until you reach a next token that has a denotation less than that of the most recent token, return the leftd
    # "lbp is a vinding power controlling operator precedence; the higher the value, the tighter a token binds to the tokens that follow"
    print "rbp: ", rbp, "token.lbp: ", token.type, token.lbp 
    while (token.type != 'SEMICOLON') and (rbp < token.lbp):
        # when the lbp is higher than the previous token's binding power, continue expression to core of highest precedence
        # set prev token to the token with higher lbp
        t = token
        # move token on
        advance()
        # and call t.leftd to do whatever that high precedenced thing was going to do the expression
        left = t.leftd(left)
    print "\treturning", left
    return left


def advance(token_type=None):
    global token
    if token_type and not isinstance(token, token_type):
        raise SyntaxError("Expected %r, got %r" % (token_type, token.__class__))
    token = next()
    return token


def next():
    # all this purely for debugging/watching flow of parsing
    global depth
    global token
    if depth > 0:
        print "Depth, Method, Token", depth, "next-ed, starting with", token.type
    depth += 1

    global remain_tokens
    if remain_tokens:
        # pop off the next token obj in the list and return it so it 
        # gets set to the global 'token'
        return remain_tokens.pop(0)
    else:
        # makes 
        return TokLast('last', 'last', 'end')



################################################################################
################################################################################
#######################       COMPILER TIME      ###############################
################################################################################
################################################################################

def generate_bytecode():
    c = Code()
    program.emit(c)
    print "Donesies"
    c.LOAD_CONST(None)
    c.RETURN_VALUE()
    # dis(c.code())
    # eval(c.code())
    print list(c)
    return c.code()


def run_tests():
    input_test = '''
    call num itemin bounds(0:10!) {
        log(num);
    }
    '''
    input_test = '''
    fun (int maxNum, string pointless, int wtf) -> fizzBuzz -> int { 
        call num itemin bounds(0:maxNum!-1) {
            if (num % 3 == 0) { 
                log("Fizz");
            }
            if (num % 5 == 0) {
                log("Buzz");
            }
            elif (num % 3 != 0) {
                log(num);
            }
        }
    }
    var string|blah = "interrupting variables on top of stack and ish";
    send(5, "DERP", 100) -> fizzbuzz;
    '''

def write_pyc(pref, code):
    f = open(pref + ".pyc", "w+")
    timestamp = time.mktime(time.gmtime())
    f.write("\x03\xf3\x0d\x0a")
    f.write(struct.pack("I", timestamp))
    marshal.dump(code, f)
    f.close()

if __name__ == "__main__":
    print sys.argv
    script, filename = sys.argv
    prefix, suffix = filename.split(".")
    em_lexer(filename)
    display_lexing()
    program = parse()
    print "\n\nHOLY GRAVY, IT PARSED. Run (evaluate) it:\n"
    program.eval()
    # print "\n\nThat took %s milliseconds." % 'undisclosed'
    print "\n\nNow that we've evaluated, let's compile: \n"
    # run_tests()
    code_obj = generate_bytecode()
    dis(code_obj)
    eval(code_obj)
    # write_pyc(prefix, code_obj)
